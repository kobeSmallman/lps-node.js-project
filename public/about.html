<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>About - Longest Palindromic Substring Analyzer</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --primary-color: #6C63FF;         /* Vibrant purple */
      --primary-dark: #5A52D9;          /* Darker purple */
      --secondary-color: #FF6B6B;       /* Coral red */
      --tertiary-color: #4ECDC4;        /* Turquoise */
      --accent-color: #FFE66D;          /* Yellow */
      --light-bg: #F7F9FC;              /* Light background */
      --card-bg: #ffffff;               /* Card background */
      --success-color: #06d6a0;         /* Success green */
      --warning-color: #FF9F1C;         /* Orange warning */
      --danger-color: #FF5252;          /* Red danger */
      --text-color: #2D3748;            /* Dark text */
      --text-light: #718096;            /* Light text */
      --border-radius: 10px;
      --box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      --transition: all 0.3s ease;
      --header-height: 70px;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 100%;
      margin: 0 auto;
      padding: 0;
      background-color: var(--light-bg);
      color: var(--text-color);
      line-height: 1.6;
      padding-top: var(--header-height);
    }
    
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: var(--header-height);
      background: linear-gradient(90deg, var(--primary-color), var(--tertiary-color));
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 2rem;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }
    
    .header .logo {
      font-size: 1.5rem;
      font-weight: bold;
      display: flex;
      align-items: center;
    }
    
    .header .logo i {
      font-size: 1.8rem;
      margin-right: 10px;
      color: var(--accent-color);
    }
    
    .nav-links {
      display: flex;
      list-style: none;
    }
    
    .nav-links li {
      margin-left: 1.5rem;
    }
    
    .nav-links a {
      color: white;
      text-decoration: none;
      font-weight: 500;
      transition: var(--transition);
      position: relative;
      padding: 5px 0;
    }
    
    .nav-links a:hover {
      color: var(--accent-color);
    }
    
    .nav-links a::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 2px;
      background-color: var(--accent-color);
      transition: var(--transition);
    }
    
    .nav-links a:hover::after {
      width: 100%;
    }
    
    .nav-links .active a {
      color: var(--accent-color);
    }
    
    .nav-links .active a::after {
      width: 100%;
    }
    
    .main-content {
      padding: 30px;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    h1, h2, h3 {
      color: var(--primary-color);
      margin-bottom: 20px;
    }
    
    h1 {
      text-align: center;
      font-size: 2.4rem;
      margin-bottom: 30px;
      border-bottom: 3px solid var(--secondary-color);
      padding-bottom: 15px;
    }
    
    h2 {
      font-size: 1.8rem;
      margin-top: 40px;
      color: var(--secondary-color);
      position: relative;
      padding-left: 20px;
    }
    
    h2::before {
      content: "";
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 10px;
      height: 25px;
      background: linear-gradient(to bottom, var(--primary-color), var(--tertiary-color));
      border-radius: 4px;
    }
    
    h3 {
      font-size: 1.4rem;
      margin-top: 25px;
      color: var(--primary-color);
      border-bottom: 2px dashed rgba(108, 99, 255, 0.2);
      padding-bottom: 8px;
      display: inline-block;
    }
    
    p {
      margin-bottom: 20px;
    }
    
    .container {
      background-color: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 40px;
      box-shadow: var(--box-shadow);
      margin-bottom: 40px;
      border-top: 5px solid var(--primary-color);
    }
    
    .section {
      margin-bottom: 40px;
    }
    
    .algorithm-card {
      background-color: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 30px;
      margin-bottom: 30px;
      border-left: 5px solid var(--primary-color);
      box-shadow: var(--box-shadow);
    }
    
    .algorithm-card.naive {
      border-left-color: var(--warning-color);
    }
    
    .algorithm-card.dp {
      border-left-color: var(--primary-color);
    }
    
    .algorithm-card.manacher {
      border-left-color: var(--tertiary-color);
    }
    
    .complexity-badge {
      display: inline-block;
      background-color: rgba(108, 99, 255, 0.1);
      padding: 3px 10px;
      border-radius: 20px;
      font-family: monospace;
      margin-left: 10px;
      font-size: 14px;
      color: var(--primary-color);
    }
    
    .creator-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      margin-bottom: 40px;
    }
    
    .creator-avatars {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin-bottom: 20px;
    }
    
    .avatar {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary-color), var(--tertiary-color));
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 40px;
      font-weight: bold;
      box-shadow: var(--box-shadow);
    }
    
    .creator-info {
      font-size: 18px;
      font-weight: 500;
      color: var(--primary-color);
    }
    
    .approach-card {
      background-color: rgba(247, 249, 252, 0.7);
      border-radius: 8px;
      padding: 25px;
      margin-top: 30px;
      border: 1px solid rgba(108, 99, 255, 0.2);
    }
    
    .feature-list {
      list-style-type: none;
      padding-left: 0;
    }
    
    .feature-list li {
      position: relative;
      padding-left: 30px;
      margin-bottom: 15px;
    }
    
    .feature-list li::before {
      content: "âœ“";
      position: absolute;
      left: 0;
      color: var(--success-color);
      font-weight: bold;
      font-size: 18px;
    }
    
    .code-block {
      background-color: #F1F5F9;
      border-radius: 8px;
      padding: 20px;
      font-family: monospace;
      overflow: auto;
      margin: 15px 0;
      border-left: 4px solid var(--tertiary-color);
      font-size: 14px;
      line-height: 1.5;
    }
    
    .diagram {
      width: 100%;
      max-width: 600px;
      margin: 30px auto;
      display: block;
      border-radius: var(--border-radius);
      border: 1px solid #eee;
      box-shadow: var(--box-shadow);
    }
    
    .algorithm-steps {
      counter-reset: step-counter;
      list-style-type: none;
      padding-left: 0;
    }
    
    .algorithm-steps li {
      counter-increment: step-counter;
      position: relative;
      padding-left: 35px;
      margin-bottom: 15px;
    }
    
    .algorithm-steps li::before {
      content: counter(step-counter);
      position: absolute;
      left: 0;
      top: 2px;
      width: 25px;
      height: 25px;
      background-color: var(--primary-color);
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
    }
    
    .emphasis {
      background-color: rgba(255, 230, 109, 0.2);
      padding: 2px 5px;
      border-radius: 4px;
      font-weight: 500;
    }
    
    .highlight-info {
      background-color: rgba(108, 99, 255, 0.1);
      border-left: 4px solid var(--primary-color);
      padding: 20px;
      margin: 20px 0;
      border-radius: 5px;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .main-content {
        padding: 15px;
      }
      
      .container {
        padding: 25px;
      }
      
      .creator-avatars {
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }
      
      .header {
        padding: 0 1rem;
      }
      
      .header .logo {
        font-size: 1.2rem;
      }
      
      .nav-links li {
        margin-left: 1rem;
      }
    }
  </style>
</head>
<body>
  <!-- Header with Navigation -->
  <header class="header">
    <div class="logo">
      <i class="fas fa-code"></i>
      <span>LPS Analyzer</span>
    </div>
    <nav>
      <ul class="nav-links">
        <li><a href="index.html">Home</a></li>
        <li class="active"><a href="about.html">About</a></li>
      </ul>
    </nav>
  </header>

  <div class="main-content">
    <h1>About the Longest Palindromic Substring Project</h1>
    
    <div class="container">
      <!-- Creators Section -->
      <div class="section creator-section">
        <h2>Created By</h2>
        <div class="creator-avatars">
          <div class="avatar">K</div>
          <div class="avatar">S</div>
        </div>
        <div class="creator-info">
          <p>Kobe Smallman & Skyler Black</p>
        </div>
      </div>
      
      <!-- Project Approach -->
      <div class="section">
        <h2>Project Approach</h2>
        <p>This project was designed to compare different algorithmic approaches to solving the classic "Longest Palindromic Substring" (LPS) problem. We chose Node.js as our platform due to its efficiency in handling asynchronous operations and its excellent performance for text processing applications.</p>
        
        <div class="approach-card">
          <h3>Why Three Different Algorithms?</h3>
          <p>The LPS problem can be solved in multiple ways, each with different trade-offs between time complexity, space complexity, and implementation complexity. By implementing three distinct approaches, we can:</p>
          <ul class="feature-list">
            <li>Compare performance across different input sizes</li>
            <li>Demonstrate how algorithmic choices impact execution time and memory usage</li>
            <li>Provide educational insights into algorithm design principles</li>
            <li>Showcase real-world applications of different time complexity classes (O(nÂ²) vs O(n))</li>
          </ul>
          
          <h3>Technical Stack</h3>
          <p>Our implementation uses:</p>
          <ul>
            <li><strong>Backend:</strong> Node.js with Express</li>
            <li><strong>Frontend:</strong> Pure HTML/CSS/JavaScript for maximum performance</li>
            <li><strong>Performance Measurement:</strong> Node.js built-in performance hooks API</li>
            <li><strong>Memory Tracking:</strong> Custom heap monitoring</li>
          </ul>
        </div>
      </div>
      
      <!-- Algorithm Details -->
      <div class="section">
        <h2>Algorithm Details</h2>
        
        <!-- Naive Approach -->
        <div class="algorithm-card naive">
          <h3>Naive Approach <span class="complexity-badge">O(nÂ²)</span></h3>
          <p>This approach finds palindromes by expanding outward from potential centers. While conceptually straightforward, our implementation includes optimizations for handling large inputs efficiently.</p>
          
          <h4>How It Works:</h4>
          <ul class="algorithm-steps">
            <li>Remove spaces and convert to lowercase for consistent comparison</li>
            <li>For inputs larger than 5000 characters, use an optimized version that avoids redundant operations</li>
            <li>For each character position in the string, consider it as a potential center of a palindrome</li>
            <li>Expand outward from each center while checking if characters match</li>
            <li>Handle both odd-length palindromes (centered at a character) and even-length palindromes (centered between characters)</li>
            <li>Track the longest palindrome found during this process</li>
            <li>Map indices back to the original string (with spaces) for the final result</li>
          </ul>
          
          <p><strong>Key Insight:</strong> The optimized implementation maintains a conceptual O(nÂ³) approach but with better implementation achieving O(nÂ²) in practice. It uses index mapping to handle spaces correctly.</p>
          
          <h4>Actual Code Implementation:</h4>
          <div class="code-block">
            <pre>function naiveLPS(s) {
  if (!s || typeof s !== 'string') {
    return '';
  }
  
  // Remove spaces and convert to lowercase for palindrome checking
  const originalStr = s;
  const processedStr = s.replace(/\s/g, '').toLowerCase();
  if (processedStr.length === 0) {
    return '';
  }
  
  // For very large inputs, use a more efficient implementation
  // This is still conceptually the naive approach but with better implementation
  if (processedStr.length > 5000) {
    console.log('Using optimized version of naive algorithm for large input');
    
    // Create mapping from processed string indices to original string indices
    const indexMapping = [];
    let processedIdx = 0;
    
    for (let i = 0; i < originalStr.length; i++) {
      if (originalStr[i].toLowerCase() !== ' ') {
        indexMapping[processedIdx] = i;
        processedIdx++;
      }
    }
    
    let maxLength = 1;
    let maxStart = 0;
    
    // Improved version of naive expansion around centers
    for (let i = 0; i < processedStr.length; i++) {
      // For odd length palindromes
      let left = i, right = i;
      while (left >= 0 && right < processedStr.length && 
             processedStr[left] === processedStr[right]) {
        const currentLength = right - left + 1;
        if (currentLength > maxLength) {
          maxLength = currentLength;
          maxStart = left;
        }
        left--;
        right++;
      }
      
      // For even length palindromes
      left = i;
      right = i + 1;
      while (left >= 0 && right < processedStr.length && 
             processedStr[left] === processedStr[right]) {
        const currentLength = right - left + 1;
        if (currentLength > maxLength) {
          maxLength = currentLength;
          maxStart = left;
        }
        left--;
        right++;
      }
    }
    
    // Map back to original string with spaces
    const origStart = indexMapping[maxStart];
    const origEnd = indexMapping[maxStart + maxLength - 1];
    
    return originalStr.substring(origStart, origEnd + 1);
  }
  
  // Standard implementation for smaller inputs
  let maxLength = 1;
  let start = 0;
  let end = 0;
  
  for (let i = 0; i < s.length; i++) {
    for (let j = i; j < s.length; j++) {
      let isPalindrome = true;
      
      // Get the substring without spaces for palindrome checking
      const subStr = s.substring(i, j + 1);
      const processedSubStr = subStr.replace(/\s/g, '').toLowerCase();
      
      // Check if it's a palindrome
      for (let k = 0; k < Math.floor(processedSubStr.length / 2); k++) {
        if (processedSubStr[k] !== processedSubStr[processedSubStr.length - k - 1]) {
          isPalindrome = false;
          break;
        }
      }
      
      // Update if a longer palindrome is found
      if (isPalindrome && processedSubStr.length > maxLength) {
        maxLength = processedSubStr.length;
        start = i;
        end = j;
      }
    }
  }
  
  return s.substring(start, end + 1);
}</pre>
          </div>

          <h4>Line-by-Line Explanation:</h4>
          <div class="highlight-info">
            <pre>if (!s || typeof s !== 'string') {
  return '';
}</pre>
            <p><strong>Input Validation:</strong> First check if the input is valid - if it's empty, null, or not a string, return an empty string. This defensive programming prevents errors with invalid inputs.</p>
            
            <pre>// Remove spaces and convert to lowercase for palindrome checking
const originalStr = s;
const processedStr = s.replace(/\s/g, '').toLowerCase();</pre>
            <p><strong>Preprocessing:</strong> We store the original string intact (spaces and all) for the final return value. Then create a processed version with all spaces removed and converted to lowercase for easier palindrome checking.</p>
            
            <pre>if (processedStr.length === 0) {
  return '';
}</pre>
            <p><strong>Edge Case:</strong> If after removing spaces the string is empty, return an empty string (e.g., input was just spaces).</p>
            
            <pre>// For very large inputs, use a more efficient implementation
if (processedStr.length > 5000) {
  // Optimized code path...
}</pre>
            <p><strong>Optimization Decision:</strong> For large inputs (>5000 chars), we switch to a more efficient implementation. This is a key part of making the algorithm practical for real-world use while maintaining the same conceptual approach.</p>
            
            <pre>// Create mapping from processed string indices to original string indices
const indexMapping = [];
let processedIdx = 0;

for (let i = 0; i < originalStr.length; i++) {
  if (originalStr[i].toLowerCase() !== ' ') {
    indexMapping[processedIdx] = i;
    processedIdx++;
  }
}</pre>
            <p><strong>Index Mapping:</strong> This creates a mapping between positions in the processed string (no spaces) and the original string (with spaces). This allows us to find the correct substring in the original text after finding palindromes in the processed text.</p>
            
            <pre>let maxLength = 1;
let maxStart = 0;</pre>
            <p><strong>Result Tracking:</strong> Initialize variables to track the maximum palindrome length found and its starting position.</p>
            
            <pre>// Improved version of naive expansion around centers
for (let i = 0; i < processedStr.length; i++) {
  // For odd length palindromes
  let left = i, right = i;
  while (left >= 0 && right < processedStr.length && 
         processedStr[left] === processedStr[right]) {
    const currentLength = right - left + 1;
    if (currentLength > maxLength) {
      maxLength = currentLength;
      maxStart = left;
    }
    left--;
    right++;
  }</pre>
            <p><strong>Odd-Length Palindrome Check:</strong> For each position in the string, treat it as a potential center of an odd-length palindrome (like "racecar"). We expand outward (left and right) as long as the characters match and we're within bounds. If we find a longer palindrome, we update our tracking variables.</p>
            
            <pre>  // For even length palindromes
  left = i;
  right = i + 1;
  while (left >= 0 && right < processedStr.length && 
         processedStr[left] === processedStr[right]) {
    const currentLength = right - left + 1;
    if (currentLength > maxLength) {
      maxLength = currentLength;
      maxStart = left;
    }
    left--;
    right++;
  }</pre>
            <p><strong>Even-Length Palindrome Check:</strong> Similarly, we check for even-length palindromes (like "abba") by starting with adjacent character positions. Same expansion logic applies.</p>
            
            <pre>// Map back to original string with spaces
const origStart = indexMapping[maxStart];
const origEnd = indexMapping[maxStart + maxLength - 1];

return originalStr.substring(origStart, origEnd + 1);</pre>
            <p><strong>Result Mapping:</strong> Once we've found the longest palindrome in the processed string, we use our index mapping to find the corresponding positions in the original string, preserving spaces and returning the exact substring from the original input.</p>
            
            <pre>// Standard implementation for smaller inputs
// [Code that runs for strings less than 5000 characters]</pre>
            <p><strong>Traditional Approach:</strong> For smaller inputs, we use the standard O(nÂ³) approach that checks every possible substring. This is simpler but less efficient. It validates each substring by checking if it's a palindrome, maintaining the same core logic of removing spaces and case insensitivity.</p>
          </div>
          
          <p><strong>Advantages:</strong> Simple to understand, works well for small inputs, suitable for educational purposes.</p>
          <p><strong>Disadvantages:</strong> Less efficient for large inputs compared to more sophisticated algorithms.</p>
          
          <div class="highlight-info">
            <i class="fas fa-lightbulb"></i> <strong>Implementation Note:</strong> Our implementation automatically switches to an optimized version for large inputs (over 5000 characters) while maintaining the same conceptual approach. This significantly improves performance while preserving the characteristics of the naive algorithm.
          </div>
          
          <div class="highlight-info" style="background-color: rgba(255, 107, 107, 0.1); border-left-color: var(--secondary-color);">
            <i class="fas fa-exclamation-circle"></i> <strong>Important Clarification:</strong> While we optimize the implementation for large inputs, it's crucial to understand that this does <em>not</em> change the theoretical time complexity of the algorithm, which remains O(nÂ²) for the optimized naive approach. The optimization reduces constant factors and improves real-world performance, but the asymptotic complexity stays the same.
            
            <p style="margin-top: 10px;"><strong>Why not use optimized versions for all inputs?</strong> For smaller inputs (under 5000 characters), the overhead of setting up the optimizations (creating index mappings, additional variable tracking) can actually be slower than the straightforward implementation. The optimization becomes beneficial only when input size grows large enough that the reduced number of operations outweighs the setup cost.</p>
          </div>
        </div>
        
        <!-- Dynamic Programming -->
        <div class="algorithm-card dp">
          <h3>Dynamic Programming <span class="complexity-badge">O(nÂ²)</span></h3>
          <p>This approach uses a table to store intermediate results, avoiding redundant calculations. Our implementation includes special handling for very large inputs to prevent memory issues.</p>
          
          <h4>How It Works:</h4>
          <ul class="algorithm-steps">
            <li>Remove spaces and convert to lowercase for consistent comparison</li>
            <li>For inputs larger than 10,000 characters, switch to a memory-efficient alternative</li>
            <li>Create a 2D table where table[i][j] represents whether the substring from index i to j is a palindrome</li>
            <li>Initialize all single characters as palindromes (diagonals in the table)</li>
            <li>Check for palindromes of length 2 (adjacent characters)</li>
            <li>Build up to longer palindromes using the knowledge of shorter palindromes</li>
            <li>For a substring to be a palindrome, its outer characters must match and its inner substring must be a palindrome</li>
            <li>Map indices back to the original string (with spaces) for the final result</li>
          </ul>
          
          <p><strong>Key Insight:</strong> The DP approach avoids redundant calculations by storing results of subproblems. In theory, this can make it more efficient than the naive approach for certain input patterns, though our optimized implementations may perform differently in practice.</p>
          
          <h4>Actual Code Implementation:</h4>
          <div class="code-block">
            <pre>function dpLPS(s) {
  if (!s || typeof s !== 'string') {
    return '';
  }
  
  // Process string by removing spaces and converting to lowercase
  const originalStr = s;
  const processedStr = s.replace(/\s/g, '').toLowerCase();
  
  if (processedStr.length === 0) {
    return '';
  }
  
  // Use a more efficient approach for very large strings to avoid memory issues
  // This prevents hanging with large inputs
  if (processedStr.length > 10000) {
    console.log('Using optimized approach for very large input in DP algorithm');
    return optimizedDPForLargeInput(originalStr, processedStr);
  }
  
  // Create mapping from processed string indices to original string indices
  const indexMapping = [];
  let processedIdx = 0;
  
  for (let i = 0; i < originalStr.length; i++) {
    if (originalStr[i].toLowerCase() !== ' ') {
      indexMapping[processedIdx] = i;
      processedIdx++;
    }
  }
  
  // Initialize table
  const n = processedStr.length;
  const table = Array(n).fill().map(() => Array(n).fill(false));
  
  // All substrings of length 1 are palindromes
  let maxLength = 1;
  let start = 0;
  
  for (let i = 0; i < n; i++) {
    table[i][i] = true;
  }
  
  // Check for substrings of length 2
  for (let i = 0; i < n - 1; i++) {
    if (processedStr[i] === processedStr[i + 1]) {
      table[i][i + 1] = true;
      start = i;
      maxLength = 2;
    }
  }
  
  // Check for lengths greater than 2
  for (let k = 3; k <= n; k++) {
    for (let i = 0; i < n - k + 1; i++) {
      const j = i + k - 1;
      
      if (table[i + 1][j - 1] && processedStr[i] === processedStr[j]) {
        table[i][j] = true;
        
        if (k > maxLength) {
          start = i;
          maxLength = k;
        }
      }
    }
  }
  
  // Map back to original string with spaces
  const origStart = indexMapping[start];
  const origEnd = indexMapping[start + maxLength - 1];
  
  return originalStr.substring(origStart, origEnd + 1);
}

function optimizedDPForLargeInput(originalStr, processedStr) {
  // Create mapping from processed string indices to original string indices
  const indexMapping = [];
  let processedIdx = 0;
  
  for (let i = 0; i < originalStr.length; i++) {
    if (originalStr[i].toLowerCase() !== ' ') {
      indexMapping[processedIdx] = i;
      processedIdx++;
    }
  }
  
  let maxLength = 0;
  let maxStart = 0;
  
  // Check all possible centers
  for (let i = 0; i < processedStr.length; i++) {
    // For odd length palindromes
    let left = i, right = i;
    while (left >= 0 && right < processedStr.length && processedStr[left] === processedStr[right]) {
      const currentLength = right - left + 1;
      if (currentLength > maxLength) {
        maxLength = currentLength;
        maxStart = left;
      }
      left--;
      right++;
    }
    
    // For even length palindromes
    left = i;
    right = i + 1;
    while (left >= 0 && right < processedStr.length && processedStr[left] === processedStr[right]) {
      const currentLength = right - left + 1;
      if (currentLength > maxLength) {
        maxLength = currentLength;
        maxStart = left;
      }
      left--;
      right++;
    }
  }
  
  // Map back to original string with spaces
  const origStart = indexMapping[maxStart];
  const origEnd = indexMapping[maxStart + maxLength - 1];
  
  return originalStr.substring(origStart, origEnd + 1);
}</pre>
          </div>

          <h4>Line-by-Line Explanation:</h4>
          <div class="highlight-info">
            <pre>if (!s || typeof s !== 'string') {
  return '';
}</pre>
            <p><strong>Input Validation:</strong> As with the naive approach, we first validate our input and handle edge cases.</p>
            
            <pre>// Process string by removing spaces and converting to lowercase
const originalStr = s;
const processedStr = s.replace(/\s/g, '').toLowerCase();</pre>
            <p><strong>Preprocessing:</strong> Store the original string and create a processed version with spaces removed and lowercase for consistent comparison.</p>
            
            <pre>if (processedStr.length > 10000) {
  console.log('Using optimized approach for very large input in DP algorithm');
  return optimizedDPForLargeInput(originalStr, processedStr);
}</pre>
            <p><strong>Memory Optimization:</strong> For very large inputs (>10,000 characters), we use a different approach (defined in the separate function below) to avoid potential memory issues. The standard DP approach uses an nÃ—n table which becomes problematic for large n.</p>
            
            <pre>// Create mapping from processed string indices to original string indices
const indexMapping = [];
let processedIdx = 0;

for (let i = 0; i < originalStr.length; i++) {
  if (originalStr[i].toLowerCase() !== ' ') {
    indexMapping[processedIdx] = i;
    processedIdx++;
  }
}</pre>
            <p><strong>Index Mapping:</strong> Create a mapping between positions in the processed string and the original string, essential for preserving spaces in our results.</p>
            
            <pre>// Initialize table
const n = processedStr.length;
const table = Array(n).fill().map(() => Array(n).fill(false));</pre>
            <p><strong>DP Table Initialization:</strong> Create an nÃ—n table where table[i][j] will be true if the substring from index i to j is a palindrome. Initially, all values are false.</p>
            
            <pre>// All substrings of length 1 are palindromes
let maxLength = 1;
let start = 0;

for (let i = 0; i < n; i++) {
  table[i][i] = true;
}</pre>
            <p><strong>Base Case:</strong> All single characters are palindromes, so we set the diagonal elements of our table to true. We also initialize our tracking variables assuming at least one character (thus a palindrome of length 1).</p>
            
            <pre>// Check for substrings of length 2
for (let i = 0; i < n - 1; i++) {
  if (processedStr[i] === processedStr[i + 1]) {
    table[i][i + 1] = true;
    start = i;
    maxLength = 2;
  }
}</pre>
            <p><strong>Two-Character Palindromes:</strong> Check adjacent characters - if they match, they form a palindrome of length 2. Update the table and tracking variables if found.</p>
            
            <pre>// Check for lengths greater than 2
for (let k = 3; k <= n; k++) {
  for (let i = 0; i < n - k + 1; i++) {
    const j = i + k - 1;
    
    if (table[i + 1][j - 1] && processedStr[i] === processedStr[j]) {
      table[i][j] = true;
      
      if (k > maxLength) {
        start = i;
        maxLength = k;
      }
    }
  }
}</pre>
            <p><strong>Building the DP Table:</strong> For substrings of length 3 and greater, we use previously computed results. A substring is a palindrome if:</p>
            <ol>
              <li>Its outer characters match (<code>processedStr[i] === processedStr[j]</code>), AND</li>
              <li>The substring inside those characters is also a palindrome (<code>table[i + 1][j - 1]</code>)</li>
            </ol>
            <p>This recursive structure is the heart of the dynamic programming approach, avoiding redundant calculations.</p>
            
            <pre>// Map back to original string with spaces
const origStart = indexMapping[start];
const origEnd = indexMapping[start + maxLength - 1];

return originalStr.substring(origStart, origEnd + 1);</pre>
            <p><strong>Result Mapping:</strong> Once we've found the longest palindrome in the processed string, we use our index mapping to find the corresponding positions in the original string, preserving spaces.</p>
            
            <pre>function optimizedDPForLargeInput(originalStr, processedStr) {
  // ...implementation similar to the expansion technique in the naive approach
}</pre>
            <p><strong>Optimized Approach for Large Inputs:</strong> This helper function uses the expand-around-center technique (similar to the optimized naive approach) but is conceptually related to dynamic programming. It avoids the memory overhead of the full DP table while maintaining efficiency.</p>
          </div>
          
          <p><strong>Advantages:</strong> Elegant solution using tabulation to avoid repeated calculations, potentially more efficient than the unoptimized naive approach for certain inputs, good balance between simplicity and performance.</p>
          <p><strong>Disadvantages:</strong> Requires O(nÂ²) space for the DP table, which can be memory-intensive for very large inputs. May have higher overhead for small inputs compared to the naive approach.</p>
          
          <div class="highlight-info">
            <i class="fas fa-lightbulb"></i> <strong>Implementation Note:</strong> Our implementation automatically falls back to a more memory-efficient algorithm for inputs over 10,000 characters to prevent memory exhaustion. This ensures reliable performance even with exceptionally large texts.
          </div>
          
          <div class="highlight-info" style="background-color: rgba(255, 107, 107, 0.1); border-left-color: var(--secondary-color);">
            <i class="fas fa-exclamation-circle"></i> <strong>Important Clarification:</strong> The memory optimization for large inputs doesn't change the theoretical time complexity of O(nÂ²) for dynamic programming. Rather, it avoids the O(nÂ²) space complexity that would otherwise cause memory issues with very large inputs.
            
            <p style="margin-top: 10px;"><strong>Why not use the optimized version for all inputs?</strong> For smaller inputs, the traditional DP approach with the 2D table has better constant factors and less overhead. The extra setup required for the optimized approach is only worth it when the input size would cause memory problems with the full DP table.</p>
          </div>
        </div>
        
        <!-- Manacher's Algorithm -->
        <div class="algorithm-card manacher">
          <h3>Manacher's Algorithm <span class="complexity-badge">O(n)</span></h3>
          <p>This specialized algorithm achieves linear time complexity by cleverly reusing previously computed information. It's the most efficient of the three algorithms, especially for large inputs.</p>
          
          <h4>How It Works:</h4>
          <ul class="algorithm-steps">
            <li>Remove spaces and convert to lowercase for consistent comparison</li>
            <li>Transform the input string by inserting special characters (e.g., '#') between each character to handle both odd and even length palindromes uniformly</li>
            <li>Initialize an array P where P[i] represents the radius (half-length) of the palindrome centered at position i</li>
            <li>Maintain two key variables:
              <ul>
                <li>C: Center of the rightmost palindrome encountered so far</li>
                <li>R: Right boundary position of that palindrome</li>
              </ul>
            </li>
            <li>For each position i:
              <ul>
                <li>Use symmetry to initialize P[i] if i is within the current right boundary R</li>
                <li>Expand around i as far as possible to find the actual palindrome radius</li>
                <li>Update C and R if the palindrome at i extends beyond the current right boundary</li>
              </ul>
            </li>
            <li>Find the maximum value in P and its corresponding center to identify the longest palindrome</li>
            <li>Map indices back to the original string (with spaces) for the final result</li>
          </ul>
          
          <p><strong>Key Insight:</strong> The linear time complexity is achieved by using the symmetry property of palindromes. When a new position i is within a known palindromic region, we can initialize P[i] based on its mirror position, avoiding redundant character comparisons.</p>
          
          <h4>Actual Code Implementation:</h4>
          <div class="code-block">
            <pre>function manacherLPS(s) {
  if (!s || typeof s !== 'string') {
    return '';
  }
  
  // Store original string and create processed string without spaces, in lowercase
  const originalStr = s;
  const processedStr = s.replace(/\s/g, '').toLowerCase();
  
  if (processedStr.length === 0) {
    return '';
  }
  
  // Create mapping from processed string indices to original string indices
  const indexMapping = [];
  let processedIdx = 0;
  
  for (let i = 0; i < originalStr.length; i++) {
    if (originalStr[i].toLowerCase() !== ' ') {
      indexMapping[processedIdx] = i;
      processedIdx++;
    }
  }
  
  // Prepare string for Manacher's algorithm
  const T = '#' + processedStr.split('').join('#') + '#';
  const n = T.length;
  const P = Array(n).fill(0);
  
  let C = 0, R = 0;
  for (let i = 1; i < n - 1; i++) {
    if (R > i) {
      P[i] = Math.min(R - i, P[2 * C - i]);
    }
    
    // Expand around center i
    while (i + P[i] + 1 < n && i - P[i] - 1 >= 0 && T[i + P[i] + 1] === T[i - P[i] - 1]) {
      P[i]++;
    }
    
    // Update center and right boundary
    if (i + P[i] > R) {
      C = i;
      R = i + P[i];
    }
  }
  
  // Find the maximum palindrome length
  let maxLen = 0;
  let centerIndex = 0;
  
  for (let i = 1; i < n - 1; i++) {
    if (P[i] > maxLen) {
      maxLen = P[i];
      centerIndex = i;
    }
  }
  
  // Convert to indices in the processed string
  const start = Math.floor((centerIndex - maxLen) / 2);
  
  // Map back to original string with spaces
  const origStart = indexMapping[start];
  const origEnd = indexMapping[start + maxLen - 1];
  
  return originalStr.substring(origStart, origEnd + 1);
}</pre>
          </div>

          <h4>Line-by-Line Explanation:</h4>
          <div class="highlight-info">
            <pre>if (!s || typeof s !== 'string') {
  return '';
}

// Store original string and create processed string without spaces, in lowercase
const originalStr = s;
const processedStr = s.replace(/\s/g, '').toLowerCase();</pre>
            <p><strong>Initial Setup:</strong> Like the other algorithms, we validate input and create a processed string with spaces removed and all characters in lowercase for consistent comparison.</p>
            
            <pre>// Create mapping from processed string indices to original string indices
const indexMapping = [];
let processedIdx = 0;

for (let i = 0; i < originalStr.length; i++) {
  if (originalStr[i].toLowerCase() !== ' ') {
    indexMapping[processedIdx] = i;
    processedIdx++;
  }
}</pre>
            <p><strong>Index Mapping:</strong> Create the mapping between processed string positions and original string positions, just as in the other algorithms.</p>
            
            <pre>// Prepare string for Manacher's algorithm
const T = '#' + processedStr.split('').join('#') + '#';
const n = T.length;
const P = Array(n).fill(0);</pre>
            <p><strong>String Transformation:</strong> This is a key step in Manacher's algorithm. We transform the string by inserting special characters (here '#') between each character and at the beginning and end. This allows us to handle both odd and even length palindromes uniformly. For example, "abba" becomes "#a#b#b#a#". We also initialize an array P where P[i] will store the radius (half-length) of the palindrome centered at position i.</p>
            
            <pre>let C = 0, R = 0;</pre>
            <p><strong>Center and Radius Tracking:</strong> Initialize variables to track:</p>
            <ul>
              <li><strong>C:</strong> The center of the rightmost palindrome found so far</li>
              <li><strong>R:</strong> The right boundary of that palindrome (C + P[C])</li>
            </ul>
            
            <pre>for (let i = 1; i < n - 1; i++) {
  if (R > i) {
    P[i] = Math.min(R - i, P[2 * C - i]);
  }</pre>
            <p><strong>Palindrome Symmetry Property:</strong> This is the key insight of Manacher's algorithm. If position i is within the right boundary of our current rightmost palindrome (R > i), we can use the symmetry property to initialize P[i] based on its mirror position, avoiding redundant character comparisons.</p>
            
            <pre>  // Expand around center i
  while (i + P[i] + 1 < n && i - P[i] - 1 >= 0 && T[i + P[i] + 1] === T[i - P[i] - 1]) {
    P[i]++;
  }</pre>
            <p><strong>Expansion Phase:</strong> We still need to expand around center i, but thanks to our initialization using symmetry, we can often skip many comparisons. This is what makes the algorithm efficient. We expand outward as long as we're within bounds and characters match.</p>
            
            <pre>  // Update center and right boundary
  if (i + P[i] > R) {
    C = i;
    R = i + P[i];
  }
}</pre>
            <p><strong>Update Rightmost Palindrome:</strong> If the palindrome centered at i extends beyond our current right boundary R, update C and R. This is essential for maintaining the invariant that [C, R] represents the rightmost palindrome found so far.</p>
            
            <pre>// Find the maximum palindrome length
let maxLen = 0;
let centerIndex = 0;

for (let i = 1; i < n - 1; i++) {
  if (P[i] > maxLen) {
    maxLen = P[i];
    centerIndex = i;
  }
}</pre>
            <p><strong>Find Maximum Palindrome:</strong> After processing all positions, we find the position i with the maximum value of P[i], which corresponds to the center of the longest palindrome.</p>
            
            <pre>// Convert to indices in the processed string
const start = Math.floor((centerIndex - maxLen) / 2);</pre>
            <p><strong>Index Conversion:</strong> Due to our string transformation, we need to convert from the position in the transformed string back to the position in the processed string. The formula (centerIndex - maxLen) / 2 accounts for the '#' characters we inserted.</p>
            
            <pre>// Map back to original string with spaces
const origStart = indexMapping[start];
const origEnd = indexMapping[start + maxLen - 1];

return originalStr.substring(origStart, origEnd + 1);</pre>
            <p><strong>Result Mapping:</strong> Finally, we use our index mapping to find the corresponding positions in the original string, preserving spaces, and return the substring.</p>
          </div>
          
          <p><strong>Advantages:</strong> Linear time complexity makes it significantly faster for large inputs, optimal asymptotic efficiency.</p>
          <p><strong>Disadvantages:</strong> More complex implementation and harder to understand intuitively, slightly higher constant factors may make it less efficient for very small inputs.</p>
          
          <div class="highlight-info">
            <i class="fas fa-lightbulb"></i> <strong>Implementation Note:</strong> The transformation step with special characters is what enables Manacher's algorithm to handle both odd and even length palindromes with a single unified approach. Combined with the clever use of symmetry, this algorithm achieves the theoretical minimum time complexity for the LPS problem.
          </div>
          
          <div class="highlight-info" style="background-color: rgba(255, 107, 107, 0.1); border-left-color: var(--secondary-color);">
            <i class="fas fa-exclamation-circle"></i> <strong>Important Clarification:</strong> Manacher's algorithm consistently maintains O(n) time complexity for all input sizes. However, it's worth noting that for small inputs, the overhead of the transformation and array initialization can make it perform worse in practice than the simpler approaches, despite its superior asymptotic efficiency.
            
            <p style="margin-top: 10px;"><strong>Why might Manacher's seem slower in benchmarks?</strong> Algorithm efficiency is about both asymptotic complexity and constant factors. For smaller inputs, the constant overhead of Manacher's algorithm can dominate its linear time advantage. Only with sufficiently large inputs will the O(n) vs O(nÂ²) difference become the determining factor in performance.</p>
          </div>
        </div>
        
        <div class="highlight-info" style="margin-top: 40px; background-color: rgba(255, 230, 109, 0.2); border-left-color: var(--warning-color);">
          <i class="fas fa-exclamation-circle"></i> <strong>Important Implementation Detail:</strong> All three algorithm implementations use the exact same approach for handling spaces and case sensitivity. They:
          <ol>
            <li>Convert the original string to lowercase and remove spaces for comparisons</li>
            <li>Maintain a mapping between processed string positions and original string positions</li>
            <li>Return the substring from the original text (with spaces preserved) as the final result</li>
          </ol>
          This ensures that all algorithms produce consistent results and can be fairly compared against each other.
        </div>
        
        <div class="highlight-info" style="margin-top: 20px; background-color: rgba(78, 205, 196, 0.1); border-left-color: var(--tertiary-color);">
          <i class="fas fa-balance-scale"></i> <strong>Performance Comparison Reality Check:</strong> 
          <p>When interpreting the performance results of these algorithms, it's important to understand that our implementations include practical optimizations that might make the benchmarks appear different from what theory would predict:</p>
          
          <ul>
            <li>The "naive" algorithm uses a more efficient implementation for large inputs that gives it O(nÂ²) performance instead of the theoretical O(nÂ³)</li>
            <li>The dynamic programming approach avoids memory issues by switching techniques for very large inputs</li>
            <li>Manacher's algorithm maintains its O(n) complexity but has higher constant overhead that can make it less efficient for smaller inputs</li>
          </ul>
          
          <p>As a result, you might see several counterintuitive performance results:</p>
          <ul>
            <li>The "naive" approach may outperform Manacher's algorithm for small to medium inputs</li>
            <li>The "naive" approach may outperform the dynamic programming approach in many cases, despite their identical O(nÂ²) asymptotic complexity</li>
            <li>Performance differences may fluctuate based on specific input patterns and system conditions</li>
          </ul>
          
          <p>These results are not flaws but reflections of the practical trade-offs between asymptotic efficiency, implementation overhead, memory access patterns, and constant factors.</p>
          
          <p>For truly enormous inputs (beyond what most users would submit), Manacher's O(n) approach would eventually outperform any O(nÂ²) approach, regardless of optimizations. However, for practical input sizes that most users will test, the theoretical advantages might not always translate to measurable performance gains.</p>
        </div>
      </div>
      
      <!-- Extended Applications of Dynamic Programming -->
      <div class="section">
        <h2>Extended Applications of Dynamic Programming</h2>
        <p>Dynamic programming (DP) isn't just about solving the Longest Palindromic Substring problemâ€”it provides a general framework that can be adapted and extended to tackle many related problems.</p>
        
        <div class="algorithm-card dp">
          <h3>Versatility and Extensibility of DP</h3>
          
          <h4>Modular Subproblem Solutions:</h4>
          <p>DP breaks a problem down into overlapping subproblems, solving each one only once and storing their results in a table. This modular approach means you can often reuse or adapt parts of the DP solution to solve similar problems that share overlapping structures.</p>
          
          <div class="code-block">
            <pre>// This DP approach for palindromes can be modified for:
// - Longest Common Subsequence
// - Longest Increasing Subsequence
// - Edit Distance problems</pre>
          </div>
          
          <h4>Customizing for Additional Constraints:</h4>
          <p>Once you have a DP framework in place, you can often add extra dimensions or modify the recurrence to handle additional constraints. For example, you might want to not only find the longest palindromic substring but also count all palindromic substrings, or find the one that meets certain criteria (like containing a specific character).</p>
          
          <h4>Adaptation to Similar Pattern Problems:</h4>
          <p>The technique used in DP for the palindromic substring problemâ€”where you build up solutions for smaller segments and then use those results to solve larger segmentsâ€”is a pattern that appears in many other problems:</p>
          <ul>
            <li><strong>Longest Common Subsequence (LCS):</strong> Comparing two sequences and finding the longest sequence common to both.</li>
            <li><strong>Edit Distance:</strong> Determining the minimum number of operations required to transform one string into another.</li>
            <li><strong>Partition Problems:</strong> Such as partitioning a set or string into palindromic parts.</li>
            <li><strong>Subset Sum and Knapsack Variants:</strong> Where you decide which items to include based on certain cumulative properties.</li>
          </ul>
          
          <h4>Facilitating Backtracking and Reconstruction:</h4>
          <p>In many DP problems, once you fill out the table, you can backtrack through it to reconstruct the actual solution. This reconstruction process itself can be adapted to yield different forms of output, which is useful when the problem specification changes or when additional information is required.</p>
          
          <div class="highlight-info">
            <p>In summary, dynamic programming offers not just a solution to a particular problem, but a powerful, adaptable methodology. It provides a structured way to handle complex problems with overlapping subproblems and optimal substructure, making it an invaluable approach for many problems in computer science.</p>
          </div>
        </div>
      </div>
      
      <!-- Implementation Approaches -->
      <div class="section">
        <h2>Implementation Approaches Comparison</h2>
        <p>When designing this project, we considered several implementation approaches. Here's an analysis of the alternatives and why we chose our current method:</p>
        
        <div class="approach-card">
          <h3>Option 1: Compiled Language (C++ in Terminal)</h3>
          
          <h4>Advantages:</h4>
          <ul class="feature-list">
            <li>High precision for performance measurements</li>
            <li>Superior execution efficiency for computationally intensive tasks</li>
            <li>Fine-grained control over memory allocation and usage</li>
          </ul>
          
          <h4>Limitations:</h4>
          <ul>
            <li>Platform-specific complexities and portability issues</li>
            <li>Longer development cycle (compile-link-run)</li>
            <li>More challenging to create user-friendly interfaces</li>
            <li>Installation requirements for end users</li>
          </ul>
          
          <div class="code-block">
            <pre>// C++ approach for precise timing
#include <chrono>
using namespace std::chrono;

auto start = high_resolution_clock::now();
std::string result = longestPalindrome(s);
auto end = high_resolution_clock::now();
auto duration = duration_cast<microseconds>(end - start);</pre>
          </div>
        </div>
        
        <div class="approach-card">
          <h3>Option 2: Pure Browser-Based Approach (Chrome)</h3>
          
          <h4>Advantages:</h4>
          <ul class="feature-list">
            <li>Easily accessible to users (no installation required)</li>
            <li>Rapid prototyping with browser developer tools</li>
            <li>Cross-platform by nature</li>
          </ul>
          
          <h4>Limitations:</h4>
          <ul>
            <li>Inaccurate memory measurements due to browser restrictions</li>
            <li>Performance varies between browsers and versions</li>
            <li>Limited control over execution environment</li>
            <li>Browser security restrictions impact measurement precision</li>
          </ul>
        </div>
        
        <div class="approach-card">
          <h3>Why We Chose Node.js</h3>
          
          <h4>Balanced Solution:</h4>
          <ul class="feature-list">
            <li>Access to precise performance metrics (process.hrtime.bigint() and process.memoryUsage())</li>
            <li>Seamless integration of front-end and back-end</li>
            <li>Consistent behavior across different operating systems</li>
            <li>Efficient deployment and minimal setup requirements</li>
          </ul>
          
          <div class="code-block">
            <pre>// Node.js approach for memory and time measurement
const memBefore = process.memoryUsage().heapUsed;
const startTime = process.hrtime.bigint();

const result = algorithm(inputText);

const endTime = process.hrtime.bigint();
const memAfter = process.memoryUsage().heapUsed;

const elapsedMs = Number(endTime - startTime) / 1_000_000;
const heapUsed = (memAfter - memBefore) / (1024 * 1024);</pre>
          </div>
          
          <p>In summary, while a C++ approach might offer raw performance benefits and a browser-only solution provides the easiest access, our Node.js implementation strikes an optimal balance between precision in performance measurement, ease of development, and a smooth user experience.</p>
        </div>
      </div>
      
      <!-- Expected Outputs -->
      <div class="section">
        <h2>Expected Outputs</h2>
        <p>The LPS Analyzer provides consistent results across all three algorithms, with specific handling of edge cases:</p>
        
        <div class="highlight-info">
          <h3>Key Behavior to Expect:</h3>
          <ul>
            <li><strong>Spaces are ignored</strong> in palindrome detection, meaning "race car" is equivalent to "racecar"</li>
            <li>Letter case is significant (e.g., "Racecar" is NOT a palindrome)</li>
            <li>When multiple palindromes of the same maximum length exist, the <strong>first occurrence</strong> is returned</li>
            <li>The length calculation excludes spaces, reflecting only the actual characters</li>
            <li>Punctuation and special characters are considered in the palindrome matching</li>
          </ul>
        </div>
        
        <h3>Example Outputs:</h3>
        <table border="1" style="width:100%; border-collapse: collapse; margin: 20px 0;">
          <thead style="background-color: rgba(108, 99, 255, 0.1);">
            <tr>
              <th style="padding: 12px;">Input Text</th>
              <th style="padding: 12px;">Longest Palindrome</th>
              <th style="padding: 12px;">Length (excluding spaces)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="padding: 12px;">"racecar"</td>
              <td style="padding: 12px;">"racecar"</td>
              <td style="padding: 12px;">7</td>
            </tr>
            <tr>
              <td style="padding: 12px;">"race car"</td>
              <td style="padding: 12px;">"race car"</td>
              <td style="padding: 12px;">7</td>
            </tr>
            <tr>
              <td style="padding: 12px;">"A man, a plan, a canal: Panama"</td>
              <td style="padding: 12px;">"a man, a plan, a canal: Panama"</td>
              <td style="padding: 12px;">21</td>
            </tr>
            <tr>
              <td style="padding: 12px;">"bob and dad are level-headed"</td>
              <td style="padding: 12px;">"level"</td>
              <td style="padding: 12px;">5</td>
            </tr>
            <tr>
              <td style="padding: 12px;">"kayak level reviver level kayak"</td>
              <td style="padding: 12px;">"kayak level reviver level kayak"</td>
              <td style="padding: 12px;">25</td>
            </tr>
          </tbody>
        </table>
      </div>
      
      <!-- How It Works -->
      <div class="section">
        <h2>How It Works</h2>
        <p>The LPS Analyzer is a full-stack application that processes text input through the following flow:</p>
        
        <h3>System Architecture:</h3>
        <div class="highlight-info">
          <ol>
            <li><strong>User Interface (Frontend):</strong> HTML/CSS/JavaScript provides an intuitive interface for text input, file uploads, and results display</li>
            <li><strong>API Layer:</strong> JavaScript code sends AJAX requests to the backend with the input text</li>
            <li><strong>Server (Node.js/Express):</strong> Receives requests and processes them through all three algorithms in parallel</li>
            <li><strong>Algorithm Processing:</strong> Each algorithm executes while performance metrics are collected</li>
            <li><strong>Response:</strong> Results including the longest palindromic substring, location indices, execution time, and memory usage are returned to the frontend</li>
            <li><strong>Results Display:</strong> The UI presents the findings with visual highlighting of the palindrome within the original text</li>
          </ol>
        </div>
        
        <h3>Performance Measurement:</h3>
        <p>The system uses Node.js built-in performance hooks to accurately measure execution time and heap usage:</p>
        <div class="code-block">
          <pre>// Time measurement
const startTime = performance.now();
const result = algorithm(inputText);
const endTime = performance.now();
const executionTime = endTime - startTime;

// Memory measurement
const memoryBefore = process.memoryUsage().heapUsed;
const result = algorithm(inputText);
const memoryAfter = process.memoryUsage().heapUsed;
const memoryUsage = memoryAfter - memoryBefore;</pre>
        </div>
        
        <h3>Space Handling:</h3>
        <p>All algorithms are implemented to ignore spaces when determining palindromes, allowing "race car" to be recognized as a palindrome equivalent to "racecar". This is achieved by skipping spaces during character comparisons while preserving the original spacing in the result.</p>
        
        <h3>Technical Considerations:</h3>
        <ul>
          <li><strong>Large Input Handling:</strong> The server is configured to accept inputs up to 10MB in size</li>
          <li><strong>Error Handling:</strong> Graceful handling of edge cases and errors with user-friendly messages</li>
          <li><strong>Responsive Design:</strong> The UI adapts to different screen sizes for optimal user experience</li>
        </ul>
      </div>
      
      <div class="section">
        <h2>About Performance Measurements</h2>
        <p>The LPS Analyzer provides detailed performance metrics for each algorithm, giving you insights into their efficiency differences.</p>
        
        <div class="algorithm-card dp">
          <h3>How We Measure Performance</h3>
          
          <h4>Execution Time:</h4>
          <p>We use the Node.js <code>performance.now()</code> API to measure the time taken by each algorithm. This provides high-resolution timing in milliseconds:</p>
          
          <div class="code-block">
            <pre>// Time measurement implementation
const startTime = performance.now();
const result = algorithm(inputString);
const endTime = performance.now();
const executionTime = endTime - startTime;</pre>
          </div>
          
          <p>Time measurements are highly reliable and consistent, accurately reflecting the computational efficiency of each algorithm.</p>
          
          <h4>Memory Usage:</h4>
          <p>Memory usage is measured by comparing heap usage before and after algorithm execution:</p>
          
          <div class="code-block">
            <pre>// Memory measurement implementation
const memBefore = process.memoryUsage().heapUsed;
const result = algorithm(inputString);
const memAfter = process.memoryUsage().heapUsed;
const memoryUsage = (memAfter - memBefore) / 1024; // Convert to KB</pre>
          </div>
          
          <h4>The Challenge with Memory Measurements</h4>
          <p>Memory measurements in Node.js can sometimes be affected by the JavaScript garbage collector, which runs automatically at unpredictable times. This can lead to several interesting phenomena:</p>
          
          <ul>
            <li><strong>Negative Memory Values:</strong> If the garbage collector runs during algorithm execution, it might free memory that was allocated before measurement started, resulting in a negative memory usage value.</li>
            <li><strong>Inconsistent Measurements:</strong> Running the same algorithm on identical input might show different memory usage each time due to garbage collection timing.</li>
            <li><strong>Occasionally Large Values:</strong> If garbage collection is delayed, memory measurements might appear larger than the actual memory needed by the algorithm.</li>
          </ul>
          
          <div class="highlight-info">
            <i class="fas fa-exclamation-triangle" style="color: var(--warning-color);"></i>
            <strong>How We Handle Measurement Issues:</strong> When memory measurement anomalies are detected, the LPS Analyzer:
            <ol>
              <li>Flags the affected measurements with an asterisk (*)</li>
              <li>Shows a tooltip explaining the issue when you hover over the value</li>
              <li>Displays a warning message at the bottom of the results</li>
            </ol>
            This approach maintains transparency while ensuring you're not misled by inaccurate measurements. It's important to note that <strong>these issues do not affect the accuracy of palindrome detection or time measurements</strong>.
          </div>
        </div>
        
        <div class="algorithm-card manacher" style="margin-top: 30px;">
          <h3>Interpreting Performance Results</h3>
          
          <p>When comparing algorithms, consider the following:</p>
          
          <ul>
            <li><strong>For Small Inputs (< 1000 characters):</strong> All three algorithms perform similarly, with the naive approach sometimes faster due to lower overhead.</li>
            <li><strong>For Medium Inputs (1000-10,000 characters):</strong> The dynamic programming and Manacher's approaches typically outperform the naive approach significantly.</li>
            <li><strong>For Large Inputs (> 10,000 characters):</strong> Manacher's algorithm typically shows the best performance, especially as input size grows.</li>
            <li><strong>Memory Usage:</strong> When reliable (not affected by garbage collection), memory measurements typically show the naive approach using less memory than DP, with Manacher's somewhere in between.</li>
          </ul>
          
          <p>For the most accurate performance analysis, we recommend focusing primarily on the execution time measurements, as they're consistent and reliable across all runs.</p>
        </div>
      </div>
    </div>
  </div>
</body>
</html> 